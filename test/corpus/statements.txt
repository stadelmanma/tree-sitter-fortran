================================================================================
Include Statements
================================================================================

PROGRAM TEST
  INCLUDE 'fftw.f03'   ! comment
  include 'other_file.h'
  interface
    include "interface.inc"
  end interface
  a = 1.0
  INCLUDE 'debug_point.f03'
contains
  include 'functions.f03'
  subroutine foo
    include "sub_body.inc.f90"
  end subroutine foo
END PROGRAM

! Check for keyword/identifier clash
module include
end module include

subroutine foo
  include 'debug.h'
  ! comment
  logical initv
  integer, parameter :: include = 1

end subroutine foo

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (include_statement
      (filename))
    (comment)
    (include_statement
      (filename))
    (interface
      (interface_statement)
      (include_statement
        (filename))
      (end_interface_statement))
    (assignment_statement
      (identifier)
      (number_literal))
    (include_statement
      (filename))
    (internal_procedures
      (contains_statement)
      (include_statement
        (filename))
      (subroutine
        (subroutine_statement
          (name))
        (include_statement
          (filename))
        (end_subroutine_statement
          (name))))
    (end_program_statement))
  (comment)
  (module
    (module_statement
      (name))
    (end_module_statement
      (name)))
  (subroutine
    (subroutine_statement
      (name))
    (include_statement
      (filename))
    (comment)
    (variable_declaration
      (intrinsic_type)
      (identifier))
    (variable_declaration
      (intrinsic_type)
      (type_qualifier)
      (init_declarator
        (identifier)
        (number_literal)))
    (end_subroutine_statement
      (name))))

================================================================================
Use Statements
================================================================================

PROGRAM TEST
  USE ISO_C_BINDING
  USE ISO_FORTRAN_ENV, ONLY : ERROR_UNIT, OUTPUT_UNIT
  USE MY_MODULE, ONLY:FUNC1
  use, intrinsic :: iso_fortran_env
  use, non_intrinsic :: iso_varying_string
  use my_module, only: func2 => foo
  use, intrinsic:: iso_fortran_env, stderr => error_unit
  use :: some_mod
  use some_mod, only:
  use some_mod, func2 => foo
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (use_statement
      (module_name))
    (use_statement
      (module_name)
      (included_items
        (identifier)
        (identifier)))
    (use_statement
      (module_name)
      (included_items
        (identifier)))
    (use_statement
      (module_name))
    (use_statement
      (module_name))
    (use_statement
      (module_name)
      (included_items
        (use_alias
          (local_name)
          (identifier))))
    (use_statement
      (module_name)
      (use_alias
        (local_name)
        (identifier)))
    (use_statement
      (module_name))
    (use_statement
      (module_name)
      (included_items))
    (use_statement
      (module_name)
      (use_alias
        (local_name)
        (identifier)))
    (end_program_statement)))

================================================================================
Implicit Statements
================================================================================

PROGRAM TEST
  IMPLICIT INTEGER(i - n), REAL(8)(r-z),  COMPLEX*8(a - c, d, e-h)
  IMPLICIT NONE
  implicit none (type, external)
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (implicit_statement
      (intrinsic_type)
      (implicit_range)
      (intrinsic_type
        (kind
          (number_literal)))
      (implicit_range)
      (intrinsic_type
        (kind
          (number_literal)))
      (implicit_range)
      (implicit_range)
      (implicit_range))
    (implicit_statement
      (none))
    (implicit_statement
      (none))
    (end_program_statement)))

================================================================================
Save Statements
================================================================================

MODULE TEST
  SAVE
  SAVE :: a, b, c, d_1
END MODULE

--------------------------------------------------------------------------------

(translation_unit
  (module
    (module_statement
      (name))
    (save_statement)
    (save_statement
      (identifier)
      (identifier)
      (identifier)
      (identifier))
    (end_module_statement)))

================================================================================
Private Statements
================================================================================

MODULE TEST
  PRIVATE
  PRIVATE :: a, b_1, operator(.and.), operator(+)
END MODULE

--------------------------------------------------------------------------------

(translation_unit
  (module
    (module_statement
      (name))
    (private_statement)
    (private_statement
      (identifier)
      (identifier)
      (operator)
      (operator))
    (end_module_statement)))

================================================================================
Public Statements
================================================================================

MODULE TEST
  PUBLIC
  PUBLIC :: a, b_1, operator(.and.), operator(+)
END MODULE

--------------------------------------------------------------------------------

(translation_unit
  (module
    (module_statement
      (name))
    (public_statement)
    (public_statement
      (identifier)
      (identifier)
      (operator)
      (operator))
    (end_module_statement)))

================================================================================
Intrinsic Variable Declarations
================================================================================

PROGRAM TEST
  INTEGER, PARAMETER :: N = 100, MXLN = 255
  INTEGER :: i, j, k, l(*)
  REAL(16) :: data(0:N**2), rhs(N), lhs(0:*)
  REAL*8, TARGET :: tmp
  REAL(KIND=8), CONTIGUOUS, POINTER :: nxt => tmp
  LOGICAL, DIMENSION(:), ALLOCATABLE :: mask
  CHARACTER(LEN=:) :: message
  CHARACTER(LEN=*) :: options
  CHARACTER*(MXLN) :: errflag
  CHARACTER(*) :: thing
  CHARACTER   FMAT*22, OTHER*(*), LIST(12)*12
  integer::no_whitespace=1
  integer(kind=c_long), bind(C, name="c_fortran_var") :: c_fortran_var
  logical, rank(rank(mask)), allocatable :: x1
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (variable_declaration
      type: (intrinsic_type)
      attribute: (type_qualifier)
      declarator: (init_declarator
        left: (identifier)
        right: (number_literal))
      declarator: (init_declarator
        left: (identifier)
        right: (number_literal)))
    (variable_declaration
      type: (intrinsic_type)
      declarator: (identifier)
      declarator: (identifier)
      declarator: (identifier)
      declarator: (sized_declarator
        (identifier)
        (size
          (assumed_size))))
    (variable_declaration
      type: (intrinsic_type
        kind: (kind
          (number_literal)))
      declarator: (sized_declarator
        (identifier)
        (size
          (extent_specifier
            (number_literal)
            (math_expression
              left: (identifier)
              right: (number_literal)))))
      declarator: (sized_declarator
        (identifier)
        (size
          (identifier)))
      declarator: (sized_declarator
        (identifier)
        (size
          (extent_specifier
            (number_literal)
            (assumed_size)))))
    (variable_declaration
      type: (intrinsic_type
        kind: (kind
          (number_literal)))
      attribute: (type_qualifier)
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type
        kind: (kind
          (keyword_argument
            name: (identifier)
            value: (number_literal))))
      attribute: (type_qualifier)
      attribute: (type_qualifier)
      declarator: (pointer_init_declarator
        left: (identifier)
        right: (identifier)))
    (variable_declaration
      type: (intrinsic_type)
      attribute: (type_qualifier
        (argument_list
          (extent_specifier)))
      attribute: (type_qualifier)
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type
        kind: (kind
          (keyword_argument
            name: (identifier)
            value: (assumed_shape))))
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type
        kind: (kind
          (keyword_argument
            name: (identifier)
            value: (assumed_size))))
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type
        kind: (kind
          (assumed_size)
          (identifier)))
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type
        kind: (kind
          (assumed_size)))
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type)
      declarator: (sized_declarator
        (identifier)
        (character_length))
      declarator: (sized_declarator
        (identifier)
        (character_length))
      declarator: (sized_declarator
        (identifier)
        (size
          (number_literal))
        (character_length)))
    (variable_declaration
      type: (intrinsic_type)
      declarator: (init_declarator
        left: (identifier)
        right: (number_literal)))
    (variable_declaration
      type: (intrinsic_type
        kind: (kind
          (keyword_argument
            name: (identifier)
            value: (identifier))))
      attribute: (language_binding
        (identifier)
        (keyword_argument
          name: (identifier)
          value: (string_literal)))
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type)
      attribute: (type_qualifier
        (argument_list
          (call_expression
            (identifier)
            (argument_list
              (identifier)))))
      attribute: (type_qualifier)
      declarator: (identifier))
    (end_program_statement)))

================================================================================
Derived Type Variable Declarations
================================================================================

PROGRAM TEST
  TYPE(CUSTOM_TYPE) :: CT
  type(real) :: r
  type(real(real32)) :: r32
  type(real(kind(1.d0))) :: r64
  type(matrix(4, 4)) :: m
  class(custom_type), pointer :: cl
  class(*), pointer :: up
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (variable_declaration
      (derived_type
        (type_name))
      (identifier))
    (variable_declaration
      (derived_type
        (intrinsic_type))
      (identifier))
    (variable_declaration
      (derived_type
        (intrinsic_type)
        (kind
          (identifier)))
      (identifier))
    (variable_declaration
      (derived_type
        (intrinsic_type)
        (kind
          (call_expression
            (identifier)
            (argument_list
              (number_literal)))))
      (identifier))
    (variable_declaration
      (derived_type
        (type_name)
        (kind
          (number_literal)
          (number_literal)))
      (identifier))
    (variable_declaration
      (derived_type
        (type_name))
      (type_qualifier)
      (identifier))
    (variable_declaration
      (derived_type
        (unlimited_polymorphic))
      (type_qualifier)
      (identifier))
    (end_program_statement)))

================================================================================
Derived Type Procedure Arguments
================================================================================

module foo
contains

subroutine test(arg1, arg2)
  type(dt), intent(in) :: arg1
  type(real), intent(out) :: arg2
end subroutine test

subroutine test2(arg1, arg2)
  class(dt), intent(in) :: arg1
  type(real(real32)), intent(out) :: arg2
end subroutine test2

subroutine test3(arg1, arg2)
  class(*), intent(in) :: arg1
  type(real(kind(1.0d0))), intent(out) :: arg2
end subroutine test3

end module foo

--------------------------------------------------------------------------------

(translation_unit
  (module
    (module_statement
      (name))
    (internal_procedures
      (contains_statement)
      (subroutine
        (subroutine_statement
          (name)
          (parameters
            (identifier)
            (identifier)))
        (variable_declaration
          (derived_type
            (type_name))
          (type_qualifier)
          (identifier))
        (variable_declaration
          (derived_type
            (intrinsic_type))
          (type_qualifier)
          (identifier))
        (end_subroutine_statement
          (name)))
      (subroutine
        (subroutine_statement
          (name)
          (parameters
            (identifier)
            (identifier)))
        (variable_declaration
          (derived_type
            (type_name))
          (type_qualifier)
          (identifier))
        (variable_declaration
          (derived_type
            (intrinsic_type)
            (kind
              (identifier)))
          (type_qualifier)
          (identifier))
        (end_subroutine_statement
          (name)))
      (subroutine
        (subroutine_statement
          (name)
          (parameters
            (identifier)
            (identifier)))
        (variable_declaration
          (derived_type
            (unlimited_polymorphic))
          (type_qualifier)
          (identifier))
        (variable_declaration
          (derived_type
            (intrinsic_type)
            (kind
              (call_expression
                (identifier)
                (argument_list
                  (number_literal)))))
          (type_qualifier)
          (identifier))
        (end_subroutine_statement
          (name))))
    (end_module_statement
      (name))))

================================================================================
Variable Modification Statements
================================================================================

PROGRAM TEST
  ALLOCATABLE :: i
  DIMENSION i(:, :), r(10)
  TARGET :: i
  PARAMETER (MAXLEN = 255, PI = 3.1415, SCALE_FACTOR = SIN(2 * PI))
  EQUIVALENCE (a, b, c), (d, e, f, r(1))
  SAVE A, B, /BLOCKC/, D
  BIND(C) n
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (variable_modification
      (type_qualifier)
      (identifier))
    (variable_modification
      (type_qualifier)
      (sized_declarator
        (identifier)
        (size
          (extent_specifier)
          (extent_specifier)))
      (sized_declarator
        (identifier)
        (size
          (number_literal))))
    (variable_modification
      (type_qualifier)
      (identifier))
    (parameter_statement
      (parameter_assignment
        (identifier)
        (number_literal))
      (parameter_assignment
        (identifier)
        (number_literal))
      (parameter_assignment
        (identifier)
        (call_expression
          (identifier)
          (argument_list
            (math_expression
              (number_literal)
              (identifier))))))
    (equivalence_statement
      (equivalence_set
        (identifier)
        (identifier)
        (identifier))
      (equivalence_set
        (identifier)
        (identifier)
        (identifier)
        (call_expression
          (identifier)
          (argument_list
            (number_literal)))))
    (save_statement
      (identifier)
      (identifier)
      (identifier)
      (identifier))
    (variable_modification
      (language_binding
        (identifier))
      (identifier))
    (end_program_statement)))

================================================================================
Do Loops
================================================================================

PROGRAM TEST
    DO i = 1, 10
      x = 6**x
      OPEN(i, FILE="qwerty")
      CALL MYSUB(i, TEST=.TRUE.)
    END DO

    DO i = 1, UBOUND(arr), step
      CONTINUE
      GOTO 44
    ENDDO

    out44: DO i = 1,INT(SIN(9.0*i))
      DO j = 1, 100, -1
        CYCLE out44
      END DO
    END DO out44

    DO WHILE (is_true)
        j = 0
    END DO

    do i = 1, 10
      if (diff) go to 100
100 end do

END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (do_loop_statement
      (loop_control_expression
        (identifier)
        (number_literal)
        (number_literal))
      (assignment_statement
        (identifier)
        (math_expression
          (number_literal)
          (identifier)))
      (open_statement
        (unit_identifier
          (identifier))
        (keyword_argument
          (identifier)
          (string_literal)))
      (subroutine_call
        (identifier)
        (argument_list
          (identifier)
          (keyword_argument
            (identifier)
            (boolean_literal))))
      (end_do_loop_statement))
    (do_loop_statement
      (loop_control_expression
        (identifier)
        (number_literal)
        (call_expression
          (identifier)
          (argument_list
            (identifier)))
        (identifier))
      (keyword_statement)
      (keyword_statement
        (statement_label_reference))
      (end_do_loop_statement))
    (do_loop_statement
      (block_label_start_expression)
      (loop_control_expression
        (identifier)
        (number_literal)
        (call_expression
          (identifier)
          (argument_list
            (call_expression
              (identifier)
              (argument_list
                (math_expression
                  (number_literal)
                  (identifier)))))))
      (do_loop_statement
        (loop_control_expression
          (identifier)
          (number_literal)
          (number_literal)
          (unary_expression
            (number_literal)))
        (keyword_statement
          (identifier))
        (end_do_loop_statement))
      (end_do_loop_statement
        (block_label)))
    (do_loop_statement
      (while_statement
        (parenthesized_expression
          (identifier)))
      (assignment_statement
        (identifier)
        (number_literal))
      (end_do_loop_statement))
    (do_loop_statement
      (loop_control_expression
        (identifier)
        (number_literal)
        (number_literal))
      (if_statement
        (parenthesized_expression
          (identifier))
        (keyword_statement
          (statement_label_reference)))
      (statement_label)
      (end_do_loop_statement))
    (end_program_statement)))

================================================================================
Do Concurrent Statement
================================================================================

PROGRAM TEST
  INTEGER,DIMENSION(N) :: J, K
  INTEGER              :: I, M
  M = 10
  I = 15
  DO CONCURRENT (I = 1:N, J(I)> 0)  LOCAL (M) SHARED (J, K) REDUCE(+:J, K) reduce(.and.:K)
     M =  MOD (K(I), J(I))
     K(I) = K(I) - M
  END DO
  PRINT *, I, M
END PROGRAM TEST

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (variable_declaration
      type: (intrinsic_type)
      attribute: (type_qualifier
        (argument_list
          (identifier)))
      declarator: (identifier)
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type)
      declarator: (identifier)
      declarator: (identifier))
    (assignment_statement
      left: (identifier)
      right: (number_literal))
    (assignment_statement
      left: (identifier)
      right: (number_literal))
    (do_loop_statement
      (concurrent_statement
        (concurrent_header
          (concurrent_control
            (identifier)
            initial: (number_literal)
            final: (identifier))
          (concurrent_mask
            (relational_expression
              left: (call_expression
                (identifier)
                (argument_list
                  (identifier)))
              right: (number_literal))))
        (concurrent_locality
          (identifier))
        (concurrent_locality
          (identifier)
          (identifier))
        (concurrent_locality
          (binary_op)
          (identifier)
          (identifier))
        (concurrent_locality
          (binary_op)
          (identifier)))
      (assignment_statement
        left: (identifier)
        right: (call_expression
          (identifier)
          (argument_list
            (call_expression
              (identifier)
              (argument_list
                (identifier)))
            (call_expression
              (identifier)
              (argument_list
                (identifier))))))
      (assignment_statement
        left: (call_expression
          (identifier)
          (argument_list
            (identifier)))
        right: (math_expression
          left: (call_expression
            (identifier)
            (argument_list
              (identifier)))
          right: (identifier)))
      (end_do_loop_statement))
    (print_statement
      (format_identifier)
      (output_item_list
        (identifier)
        (identifier)))
    (end_program_statement
      (name))))

================================================================================
Do Label Statement (Obsolescent)
================================================================================

program test
  do 10 i = 1, 10
    do 10, j = 1, 10
      foo(i, j) = i * j
10 continue

  do 10 i = 1, 10
    bar(i) = i
10 end do
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (do_label_statement
      (statement_label_reference)
      (loop_control_expression
        (identifier)
        (number_literal)
        (number_literal)))
    (do_label_statement
      (statement_label_reference)
      (loop_control_expression
        (identifier)
        (number_literal)
        (number_literal)))
    (assignment_statement
      (call_expression
        (identifier)
        (argument_list
          (identifier)
          (identifier)))
      (math_expression
        (identifier)
        (identifier)))
    (statement_label)
    (keyword_statement)
    (do_label_statement
      (statement_label_reference)
      (loop_control_expression
        (identifier)
        (number_literal)
        (number_literal)))
    (assignment_statement
      (call_expression
        (identifier)
        (argument_list
          (identifier)))
      (identifier))
    (end_do_label_statement
      (statement_label))
    (end_program_statement
      (name))))

================================================================================
Computed Goto (Obsolescent)
================================================================================

program test
  goto (10, 20, 30) M
  goto (10, 20, 30) ISAVE(1)
end program

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (keyword_statement
      (statement_label_reference)
      (statement_label_reference)
      (statement_label_reference)
      (identifier))
    (keyword_statement
      (statement_label_reference)
      (statement_label_reference)
      (statement_label_reference)
      (call_expression
        (identifier)
        (argument_list
          (number_literal))))
    (end_program_statement)))

================================================================================
If Statements
================================================================================

PROGRAM TEST
  IF (x<7) y = 9
  if(ix.ge.1.and.2.le.nx)x=1.4

  IF (arg(1:1) == ADJUSTL(' r')) THEN
    r = 0
  ELSE IF (arg(1:1) .NE. CHAR(l(1))) THEN
    l = 67
  ELSE IF (arg(1:1) .NE. CHAR(m(1))) THEN
  ELSE
    n = 0
  ENDIF

  cond1: IF (y < 0) THEN
     y = 9
  ELSE  IF (x > 0) THEN cond1
   r = 9
   IF (arg(1:1)) THEN
     r = 0
   ELSE
     n = 0
   END IF
  ELSE cond1
    y = 10
  END IF cond1
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (if_statement
      (parenthesized_expression
        (relational_expression
          (identifier)
          (number_literal)))
      (assignment_statement
        (identifier)
        (number_literal)))
    (if_statement
      (parenthesized_expression
        (logical_expression
          (relational_expression
            (identifier)
            (number_literal))
          (relational_expression
            (number_literal)
            (identifier))))
      (assignment_statement
        (identifier)
        (number_literal)))
    (if_statement
      (parenthesized_expression
        (relational_expression
          (call_expression
            (identifier)
            (argument_list
              (extent_specifier
                (number_literal)
                (number_literal))))
          (call_expression
            (identifier)
            (argument_list
              (string_literal)))))
      (assignment_statement
        (identifier)
        (number_literal))
      (elseif_clause
        (parenthesized_expression
          (relational_expression
            (call_expression
              (identifier)
              (argument_list
                (extent_specifier
                  (number_literal)
                  (number_literal))))
            (call_expression
              (identifier)
              (argument_list
                (call_expression
                  (identifier)
                  (argument_list
                    (number_literal)))))))
        (assignment_statement
          (identifier)
          (number_literal)))
      (elseif_clause
        (parenthesized_expression
          (relational_expression
            (call_expression
              (identifier)
              (argument_list
                (extent_specifier
                  (number_literal)
                  (number_literal))))
            (call_expression
              (identifier)
              (argument_list
                (call_expression
                  (identifier)
                  (argument_list
                    (number_literal))))))))
      (else_clause
        (assignment_statement
          (identifier)
          (number_literal)))
      (end_if_statement))
    (if_statement
      (block_label_start_expression)
      (parenthesized_expression
        (relational_expression
          (identifier)
          (number_literal)))
      (assignment_statement
        (identifier)
        (number_literal))
      (elseif_clause
        (parenthesized_expression
          (relational_expression
            (identifier)
            (number_literal)))
        (block_label)
        (assignment_statement
          (identifier)
          (number_literal))
        (if_statement
          (parenthesized_expression
            (call_expression
              (identifier)
              (argument_list
                (extent_specifier
                  (number_literal)
                  (number_literal)))))
          (assignment_statement
            (identifier)
            (number_literal))
          (else_clause
            (assignment_statement
              (identifier)
              (number_literal)))
          (end_if_statement)))
      (else_clause
        (block_label)
        (assignment_statement
          (identifier)
          (number_literal)))
      (end_if_statement
        (block_label)))
    (end_program_statement)))

================================================================================
Where Statements
================================================================================

program test

WHERE(A .NE. 0) C = B / A

WHERE(PRESSURE .GE. 1.0)
  PRESSURE = PRESSURE + 1.0
  TEMP = TEMP - 10.0
ELSEWHERE (PRESSURE .LE. 2.0)
  PRESSURE = PRESSURE - 1.0
ELSEWHERE
  PRECIPITATION = .TRUE.
ENDWHERE

cond1: WHERE(PRESSURE .GE. 1.0)
  PRESSURE = PRESSURE + 1.0
ELSEWHERE (PRESSURE .LE. 2.0) cond1
  PRESSURE = PRESSURE - 1.0
ELSEWHERE cond1
  PRECIPITATION = .TRUE.
ENDWHERE cond1

end program

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (where_statement
      (parenthesized_expression
        (relational_expression
          (identifier)
          (number_literal)))
      (assignment_statement
        (identifier)
        (math_expression
          (identifier)
          (identifier))))
    (where_statement
      (parenthesized_expression
        (relational_expression
          (identifier)
          (number_literal)))
      (assignment_statement
        (identifier)
        (math_expression
          (identifier)
          (number_literal)))
      (assignment_statement
        (identifier)
        (math_expression
          (identifier)
          (number_literal)))
      (elsewhere_clause
        (parenthesized_expression
          (relational_expression
            (identifier)
            (number_literal)))
        (assignment_statement
          (identifier)
          (math_expression
            (identifier)
            (number_literal))))
      (elsewhere_clause
        (assignment_statement
          (identifier)
          (boolean_literal)))
      (end_where_statement))
    (where_statement
      (block_label_start_expression)
      (parenthesized_expression
        (relational_expression
          (identifier)
          (number_literal)))
      (assignment_statement
        (identifier)
        (math_expression
          (identifier)
          (number_literal)))
      (elsewhere_clause
        (parenthesized_expression
          (relational_expression
            (identifier)
            (number_literal)))
        (block_label)
        (assignment_statement
          (identifier)
          (math_expression
            (identifier)
            (number_literal))))
      (elsewhere_clause
        (block_label)
        (assignment_statement
          (identifier)
          (boolean_literal)))
      (end_where_statement
        (block_label)))
    (end_program_statement)))

================================================================================
Forall Statements
================================================================================

PROGRAM TEST

FORALL(I = 1:N, J = 1:N, A(I, J) .NE. 0.0) B(I, J) = 1.0 / A(I, J)

FORALL(J=1:8)  PATTERN(J)%P => OBJECT(1+IEOR(J-1,2))


FORALL (I = 1:N, J = 1:N)
  WHERE(A(I, J) .NE. 0.0) B(I, J) = 1.0/A(I, J)
END FORALL

FORALL(I = 3:N + 1, J = 3:N + 1, A(I, J) > 0.0)
  C(I, J) = C(I, J + 2) + C(I, J - 2) + C(I + 2, J) + C(I - 2, J)
  D(I, J) = C(I, J)
END FORALL

END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (forall_statement
      (triplet_spec
        (identifier)
        (number_literal)
        (identifier))
      (triplet_spec
        (identifier)
        (number_literal)
        (identifier))
      (relational_expression
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (number_literal))
      (assignment_statement
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (math_expression
          (number_literal)
          (call_expression
            (identifier)
            (argument_list
              (identifier)
              (identifier))))))
    (forall_statement
      (triplet_spec
        (identifier)
        (number_literal)
        (number_literal))
      (pointer_association_statement
        (derived_type_member_expression
          (call_expression
            (identifier)
            (argument_list
              (identifier)))
          (type_member))
        (call_expression
          (identifier)
          (argument_list
            (math_expression
              (number_literal)
              (call_expression
                (identifier)
                (argument_list
                  (math_expression
                    (identifier)
                    (number_literal))
                  (number_literal))))))))
    (forall_statement
      (triplet_spec
        (identifier)
        (number_literal)
        (identifier))
      (triplet_spec
        (identifier)
        (number_literal)
        (identifier))
      (where_statement
        (parenthesized_expression
          (relational_expression
            (call_expression
              (identifier)
              (argument_list
                (identifier)
                (identifier)))
            (number_literal)))
        (assignment_statement
          (call_expression
            (identifier)
            (argument_list
              (identifier)
              (identifier)))
          (math_expression
            (number_literal)
            (call_expression
              (identifier)
              (argument_list
                (identifier)
                (identifier))))))
      (end_forall_statement))
    (forall_statement
      (triplet_spec
        (identifier)
        (number_literal)
        (math_expression
          (identifier)
          (number_literal)))
      (triplet_spec
        (identifier)
        (number_literal)
        (math_expression
          (identifier)
          (number_literal)))
      (relational_expression
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (number_literal))
      (assignment_statement
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (math_expression
          (math_expression
            (math_expression
              (call_expression
                (identifier)
                (argument_list
                  (identifier)
                  (math_expression
                    (identifier)
                    (number_literal))))
              (call_expression
                (identifier)
                (argument_list
                  (identifier)
                  (math_expression
                    (identifier)
                    (number_literal)))))
            (call_expression
              (identifier)
              (argument_list
                (math_expression
                  (identifier)
                  (number_literal))
                (identifier))))
          (call_expression
            (identifier)
            (argument_list
              (math_expression
                (identifier)
                (number_literal))
              (identifier)))))
      (assignment_statement
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier))))
      (end_forall_statement))
    (end_program_statement)))

================================================================================
Select Case Statements
================================================================================

PROGRAM TEST
  sign_case: SELECT CASE (number)
  CASE (: -1) sign_case
    sign = -1
  CASE (0) sign_case
    sign = 0
  CASE (1 :) sign_case
    sign = 1
  END SELECT sign_case

  SELECT CASE (c)
  CASE ('a' : 'm', 'n' : 'z')
    WRITE(*,*) 'lowercase letter'
  CASE ('A' : 'Z')
    WRITE(*,*) 'uppercase letter'
  CASE (WILDCARD_CHAR)
    WRITE(*,*) 'wildcard letter'
  CASE DEFAULT
    WRITE(*,*)  'Other characters, which may not be letters'
  END SELECT
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (select_case_statement
      (block_label_start_expression)
      (selector
        (identifier))
      (case_statement
        (case_value_range_list
          (extent_specifier
            (unary_expression
              (number_literal))))
        (block_label)
        (assignment_statement
          (identifier)
          (unary_expression
            (number_literal))))
      (case_statement
        (case_value_range_list
          (number_literal))
        (block_label)
        (assignment_statement
          (identifier)
          (number_literal)))
      (case_statement
        (case_value_range_list
          (extent_specifier
            (number_literal)))
        (block_label)
        (assignment_statement
          (identifier)
          (number_literal)))
      (end_select_statement
        (block_label)))
    (select_case_statement
      (selector
        (identifier))
      (case_statement
        (case_value_range_list
          (extent_specifier
            (string_literal)
            (string_literal))
          (extent_specifier
            (string_literal)
            (string_literal)))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list
            (string_literal))))
      (case_statement
        (case_value_range_list
          (extent_specifier
            (string_literal)
            (string_literal)))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list
            (string_literal))))
      (case_statement
        (case_value_range_list
          (identifier))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list
            (string_literal))))
      (case_statement
        (default)
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list
            (string_literal))))
      (end_select_statement))
    (end_program_statement)))

================================================================================
Format Statements
================================================================================

PROGRAM TEST
1 FORMAT('1234', a5, a5a5)
2 FORMAT(2F8.3, F6.2, //, :)
3 FORMAT(I0, A(2X, I3), 'test')
4 FORMAT(*(G15.8,:,','))
5 FORMAT(/1X,'NUMBER OF DATA Total/ACCEPTED'/1X,i10/1X)
6 FORMAT(3(1H-), 2HOK, 10H SOLUTION // 5D15.7)
7 FORMAT(6x, 10Hv=1, w=x/2)
8 FORMAT(/5hhello)
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (statement_label)
    (format_statement
      (transfer_items
        (string_literal)
        (edit_descriptor)
        (edit_descriptor)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (string_literal)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (string_literal)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (edit_descriptor)
        (string_literal)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (hollerith_constant)
        (hollerith_constant)
        (hollerith_constant)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (hollerith_constant)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (hollerith_constant)))
    (end_program_statement)))

================================================================================
Read Statements
================================================================================

PROGRAM TEST
  READ *, x
  READ 9, x
  READ(*)
  READ(*, *)
  READ(10, 100) x, y, z
  READ(10,*,iostat=ioerr)
  READ(IOUNIT, FMT="(FORMAT STRING)") flags(:)
  READ(UNIT=IOUNIT, FMT="(FORMAT STRING)", IOSTAT=IOS, ADVANCE='NO') X
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (read_statement
      (format_identifier)
      (input_item_list
        (identifier)))
    (read_statement
      (format_identifier
        (statement_label_reference))
      (input_item_list
        (identifier)))
    (read_statement
      (unit_identifier))
    (read_statement
      (unit_identifier)
      (format_identifier))
    (read_statement
      (unit_identifier
        (number_literal))
      (format_identifier
        (statement_label_reference))
      (input_item_list
        (identifier)
        (identifier)
        (identifier)))
    (read_statement
      (unit_identifier
        (number_literal))
      (format_identifier)
      (keyword_argument
        (identifier)
        (identifier)))
    (read_statement
      (unit_identifier
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal))
      (input_item_list
        (call_expression
          (identifier)
          (argument_list
            (extent_specifier)))))
    (read_statement
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal))
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal))
      (input_item_list
        (identifier)))
    (end_program_statement)))

================================================================================
Print Statements
================================================================================

PROGRAM TEST
  PRINT *
  PRINT *, 'test'
  PRINT IUNIT, x, y, z
  print'(a)', "hello"
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (print_statement
      (format_identifier))
    (print_statement
      (format_identifier)
      (output_item_list
        (string_literal)))
    (print_statement
      (format_identifier
        (identifier))
      (output_item_list
        (identifier)
        (identifier)
        (identifier)))
    (print_statement
      (format_identifier
        (string_literal))
      (output_item_list
        (string_literal)))
    (end_program_statement)))

================================================================================
Write Statements
================================================================================

PROGRAM TEST
  WRITE(*)
  WRITE(*, *) ''
  WRITE(10, 100) x, y, z
  WRITE(IOUNIT, "(FORMAT STRING)", IOSTAT=IOS)
  WRITE(IOUNIT, FMT="(FORMAT STRING)") flags(:)
  WRITE(UNIT=IOUNIT, FMT="(FORMAT STRING)", IOSTAT=IOS, ADVANCE='NO') X
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (write_statement
      (unit_identifier))
    (write_statement
      (unit_identifier)
      (format_identifier)
      (output_item_list
        (string_literal)))
    (write_statement
      (unit_identifier
        (number_literal))
      (format_identifier
        (statement_label_reference))
      (output_item_list
        (identifier)
        (identifier)
        (identifier)))
    (write_statement
      (unit_identifier
        (identifier))
      (format_identifier
        (string_literal))
      (keyword_argument
        (identifier)
        (identifier)))
    (write_statement
      (unit_identifier
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal))
      (output_item_list
        (call_expression
          (identifier)
          (argument_list
            (extent_specifier)))))
    (write_statement
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal))
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal))
      (output_item_list
        (identifier)))
    (end_program_statement)))

================================================================================
Import Statements
================================================================================

function test()
  import :: dp, cptr
end function test
function test2()
  import c_size_t, c_ptr
end function test2
function test3(self)
  import
  class(self_type), intent(inout) :: self
end function test3
function test4()
  import, only : dp
end function test4

--------------------------------------------------------------------------------

(translation_unit
  (function
    (function_statement
      (name))
    (import_statement
      (identifier)
      (identifier))
    (end_function_statement
      (name)))
  (function
    (function_statement
      (name))
    (import_statement
      (identifier)
      (identifier))
    (end_function_statement
      (name)))
  (function
    (function_statement
      (name)
      (parameters
        (identifier)))
    (import_statement)
    (variable_declaration
      (derived_type
        (type_name))
      (type_qualifier)
      (identifier))
    (end_function_statement
      (name)))
  (function
    (function_statement
      (name))
    (import_statement
      (identifier))
    (end_function_statement
      (name))))

================================================================================
Common Statement
================================================================================

PROGRAM TEST
  COMMON /blk1/ m, n /blk2/ o
  COMMON /blk3/ a(1), b(2, 3)
  COMMON p
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (common_statement
      (variable_group
        (name)
        (identifier)
        (identifier))
      (variable_group
        (name)
        (identifier)))
    (common_statement
      (variable_group
        (name)
        (sized_declarator
          (identifier)
          (size
            (number_literal)))
        (sized_declarator
          (identifier)
          (size
            (number_literal)
            (number_literal)))))
    (common_statement
      (identifier))
    (end_program_statement)))

================================================================================
Namelist Statement
================================================================================

PROGRAM TEST
  INTEGER :: i, j
  REAL :: a, b
  namelist /test/ i,j /test2/ a,b
END PROGRAM

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (variable_declaration
      (intrinsic_type)
      (identifier)
      (identifier))
    (variable_declaration
      (intrinsic_type)
      (identifier)
      (identifier))
    (namelist_statement
      (variable_group
        (name)
        (identifier)
        (identifier))
      (variable_group
        (name)
        (identifier)
        (identifier)))
    (end_program_statement)))

================================================================================
Enum Statements
================================================================================

PROGRAM test
    ENUM, BIND(C)
        ENUMERATOR :: red = 1
        ENUMERATOR blue, green
    END ENUM
    ENUM, BIND(C)
        ENUMERATOR :: minus_one = -1
    END ENUM
END PROGRAM test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (enum
      (enum_statement
        (language_binding
          (identifier)))
      (enumerator_statement
        declarator: (init_declarator
          left: (identifier)
          right: (number_literal)))
      (enumerator_statement
        declarator: (identifier)
        declarator: (identifier))
      (end_enum_statement))
    (enum
      (enum_statement
        (language_binding
          (identifier)))
      (enumerator_statement
        declarator: (init_declarator
          left: (identifier)
          right: (unary_expression
            argument: (number_literal))))
      (end_enum_statement))
    (end_program_statement
      (name))))

================================================================================
Select Type Statement
================================================================================

subroutine print_decorated_numbers(number)
  class(*), intent(in) :: number

  select type(number)
  type is (integer)
    write(*, '("<", i0, ">")') number
  type is (real(kind(1.0)))
    write(*, '("(", f8.5, ")")') number
  type is (real(kind(1.0d0)))
    write(*, '("{", f13.8, "}")') number
  type is (complex)
    write(*, '("[", f13.8, " + ", f13.8 "i]")') number
  class is (custom_type)
    write(*, '("#", f8.5, "#")') number%value
  class default
    write(*, '("~Not a number~")')
  end select
end subroutine print_decorated_numbers

--------------------------------------------------------------------------------

(translation_unit
  (subroutine
    (subroutine_statement
      (name)
      (parameters
        (identifier)))
    (variable_declaration
      (derived_type
        (unlimited_polymorphic))
      (type_qualifier)
      (identifier))
    (select_type_statement
      (selector
        (identifier))
      (type_statement
        (intrinsic_type)
        (write_statement
          (unit_identifier)
          (format_identifier
            (string_literal))
          (output_item_list
            (identifier))))
      (type_statement
        (intrinsic_type
          (kind
            (call_expression
              (identifier)
              (argument_list
                (number_literal)))))
        (write_statement
          (unit_identifier)
          (format_identifier
            (string_literal))
          (output_item_list
            (identifier))))
      (type_statement
        (intrinsic_type
          (kind
            (call_expression
              (identifier)
              (argument_list
                (number_literal)))))
        (write_statement
          (unit_identifier)
          (format_identifier
            (string_literal))
          (output_item_list
            (identifier))))
      (type_statement
        (intrinsic_type)
        (write_statement
          (unit_identifier)
          (format_identifier
            (string_literal))
          (output_item_list
            (identifier))))
      (type_statement
        (identifier)
        (write_statement
          (unit_identifier)
          (format_identifier
            (string_literal))
          (output_item_list
            (derived_type_member_expression
              (identifier)
              (type_member)))))
      (type_statement
        (default)
        (write_statement
          (unit_identifier)
          (format_identifier
            (string_literal))))
      (end_select_statement))
    (end_subroutine_statement
      (name))))

================================================================================
Open/Close statements
================================================================================

program test
  integer :: unit

  open(newunit=unit, file="foo.txt")
  close(unit, status="delete")

  open(newunit=unit, file="foo.txt")
  close(unit=unit, status="delete")

  open(99)
  close(99)
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (variable_declaration
      (intrinsic_type)
      (identifier))
    (open_statement
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal)))
    (close_statement
      (unit_identifier
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal)))
    (open_statement
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal)))
    (close_statement
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (string_literal)))
    (open_statement
      (unit_identifier
        (number_literal)))
    (close_statement
      (unit_identifier
        (number_literal)))
    (end_program_statement
      (name))))

================================================================================
Select Rank and Assumed Rank
================================================================================

subroutine assumed_rank(A)
  integer, intent(inout) :: A(..)

  select rank(A)
    rank (0)
      write(*, *) "scalar"
    rank (1)
      write(*, *) "rank 1"
    rank (2)
      write(*, *) "rank 2"
    rank default
      error stop 'assumed_rank: only rank 0..2 is handled for now.'
  end select
end subroutine assumed_rank

--------------------------------------------------------------------------------

(translation_unit
  (subroutine
    (subroutine_statement
      (name)
      (parameters
        (identifier)))
    (variable_declaration
      (intrinsic_type)
      (type_qualifier)
      (sized_declarator
        (identifier)
        (size
          (assumed_rank))))
    (select_rank_statement
      (selector
        (identifier))
      (rank_statement
        (case_value_range_list
          (number_literal))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list
            (string_literal))))
      (rank_statement
        (case_value_range_list
          (number_literal))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list
            (string_literal))))
      (rank_statement
        (case_value_range_list
          (number_literal))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list
            (string_literal))))
      (rank_statement
        (default)
        (stop_statement
          (string_literal)))
      (end_select_statement))
    (end_subroutine_statement
      (name))))

================================================================================
Associate Statement
================================================================================

program test
  associate(foo => bar, bing => bat)
    inner:associate(this => that%other())
        foo = this + 1
    end associate inner
  end associate
end program

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (associate_statement
      (association
        (identifier)
        (identifier))
      (association
        (identifier)
        (identifier))
      (associate_statement
        (block_label_start_expression)
        (association
          (identifier)
          (call_expression
            (derived_type_member_expression
              (identifier)
              (type_member))
            (argument_list)))
        (assignment_statement
          (identifier)
          (math_expression
            (identifier)
            (number_literal)))
        (end_associate_statement
          (block_label)))
      (end_associate_statement))
    (end_program_statement)))

================================================================================
User Defined Operator
================================================================================

program foo
  interface operator(.unary.)
    integer function unary_op(x)
      integer, intent(in) :: x
    end function unary_op
  end interface

  interface operator(.binary.)
    integer function binary_op(x, y)
      integer, intent(in) :: x, y
    end function unary_op
  end interface

  integer :: a, b
  print*, . unary . a
  print*, b .binary. a

end program

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (interface
      (interface_statement
        (operator))
      (function
        (function_statement
          (intrinsic_type)
          (name)
          (parameters
            (identifier)))
        (variable_declaration
          (intrinsic_type)
          (type_qualifier)
          (identifier))
        (end_function_statement
          (name)))
      (end_interface_statement))
    (interface
      (interface_statement
        (operator))
      (function
        (function_statement
          (intrinsic_type)
          (name)
          (parameters
            (identifier)
            (identifier)))
        (variable_declaration
          (intrinsic_type)
          (type_qualifier)
          (identifier)
          (identifier))
        (end_function_statement
          (name)))
      (end_interface_statement))
    (variable_declaration
      (intrinsic_type)
      (identifier)
      (identifier))
    (print_statement
      (format_identifier)
      (output_item_list
        (unary_expression
          (user_defined_operator)
          (identifier))))
    (print_statement
      (format_identifier)
      (output_item_list
        (math_expression
          (identifier)
          (user_defined_operator)
          (identifier))))
    (end_program_statement)))

================================================================================
Defined IO Procedures
================================================================================

module test
  use other, only : write(unformatted), read(formatted)
  implicit none

  public :: read(unformatted)
  private :: write(formatted)

  interface write(formatted)
    module procedure :: write_formatted
  end interface

  interface read(formatted)
    module procedure read_formatted
  end interface read(formatted)

  type foo
  contains
    ! User defined IO
    generic, public :: write(formatted) => write_formatted
    ! Just some function called read
    procedure, public :: read => read_foo
  end type foo
end module

--------------------------------------------------------------------------------

(translation_unit
  (module
    (module_statement
      (name))
    (use_statement
      (module_name)
      (included_items
        (defined_io_procedure)
        (defined_io_procedure)))
    (implicit_statement
      (none))
    (public_statement
      (defined_io_procedure))
    (private_statement
      (defined_io_procedure))
    (interface
      (interface_statement
        (defined_io_procedure))
      (procedure_statement
        (procedure_kind)
        (method_name))
      (end_interface_statement))
    (interface
      (interface_statement
        (defined_io_procedure))
      (procedure_statement
        (procedure_kind)
        (method_name))
      (end_interface_statement
        (defined_io_procedure)))
    (derived_type_definition
      (derived_type_statement
        (type_name))
      (derived_type_procedures
        (contains_statement)
        (comment)
        (procedure_statement
          (procedure_kind)
          (procedure_attribute)
          (binding
            (binding_name
              (defined_io_procedure))
            (method_name)))
        (comment)
        (procedure_statement
          (procedure_kind)
          (procedure_attribute)
          (binding
            (binding_name
              (identifier))
            (method_name))))
      (end_type_statement
        (name)))
    (end_module_statement)))

================================================================================
Data statement
================================================================================

program test
  data a, b /1, 2/, c /3, 4/d/5,6/
  data list / null() /
  data bool / .true. /
  data foo%bar / "hello" /
  DATA person / Person_t(42, "Test Name") /
  DATA (array(1,k),k=1,n) /3.14e-3, -42.5/
  DATA array(:, N) / &
    54.45_fp, 200.01_fp /
  DATA complex_array / ( 0, 1 ), ( 1, 0 ) /
  data params/ param1, param2/

  ! This is awful, but this makes sure the specification part has
  ! finished, as is a hacky workaround to make sure the next part is
  ! parsed correctly
  x = 4

  ! Check data is still ok as identifier
  data(n) = 54
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (data_statement
      (data_set
        (identifier)
        (identifier)
        (data_value
          (number_literal)
          (number_literal)))
      (data_set
        (identifier)
        (data_value
          (number_literal)
          (number_literal)))
      (data_set
        (identifier)
        (data_value
          (number_literal)
          (number_literal))))
    (data_statement
      (data_set
        (identifier)
        (data_value
          (null_literal))))
    (data_statement
      (data_set
        (identifier)
        (data_value
          (boolean_literal))))
    (data_statement
      (data_set
        (derived_type_member_expression
          (identifier)
          (type_member))
        (data_value
          (string_literal))))
    (data_statement
      (data_set
        (identifier)
        (data_value
          (call_expression
            (identifier)
            (argument_list
              (number_literal)
              (string_literal))))))
    (data_statement
      (data_set
        (implied_do_loop_expression
          (call_expression
            (identifier)
            (argument_list
              (number_literal)
              (identifier)))
          (loop_control_expression
            (identifier)
            (number_literal)
            (identifier)))
        (data_value
          (number_literal)
          (unary_expression
            (number_literal)))))
    (data_statement
      (data_set
        (call_expression
          (identifier)
          (argument_list
            (extent_specifier)
            (identifier)))
        (data_value
          (number_literal
            (identifier))
          (number_literal
            (identifier)))))
    (data_statement
      (data_set
        (identifier)
        (data_value
          (complex_literal
            (number_literal)
            (number_literal))
          (complex_literal
            (number_literal)
            (number_literal)))))
    (data_statement
      (data_set
        (identifier)
        (data_value
          (identifier)
          (identifier))))
    (comment)
    (comment)
    (comment)
    (assignment_statement
      (identifier)
      (number_literal))
    (comment)
    (assignment_statement
      (call_expression
        (identifier)
        (argument_list
          (identifier)))
      (number_literal))
    (end_program_statement
      (name))))

================================================================================
File Position Statments
================================================================================

program test
  backspace 2
  backspace (10, iostat=N)

  endfile k
  endfile (unit=self%scratch, iostat=error)

  rewind(11)
  rewind(lu_prof(N))

  pause 'this is deleted'
end program

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (file_position_statement
      (unit_identifier
        (number_literal)))
    (file_position_statement
      (unit_identifier
        (number_literal))
      (keyword_argument
        (identifier)
        (identifier)))
    (file_position_statement
      (unit_identifier
        (identifier)))
    (file_position_statement
      (keyword_argument
        (identifier)
        (derived_type_member_expression
          (identifier)
          (type_member)))
      (keyword_argument
        (identifier)
        (identifier)))
    (file_position_statement
      (unit_identifier
        (parenthesized_expression
          (number_literal))))
    (file_position_statement
      (unit_identifier
        (parenthesized_expression
          (call_expression
            (identifier)
            (argument_list
              (identifier))))))
    (file_position_statement
      (string_literal))
    (end_program_statement)))

================================================================================
Inquire Statements
================================================================================

program test
  INQUIRE (IOLENGTH = IOL) A (1:N)
  INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &
           FORM = CHAR_VAR, IOSTAT = IOS)
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (inquire_statement
      (keyword_argument
        (identifier)
        (identifier))
      (output_item_list
        (call_expression
          (identifier)
          (argument_list
            (extent_specifier
              (number_literal)
              (identifier))))))
    (inquire_statement
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (identifier))
      (keyword_argument
        (identifier)
        (identifier)))
    (end_program_statement
      (name))))

================================================================================
Allocate statements
================================================================================

program test
    allocate(my_int(1, 2))
    allocate(integer::foo)
    allocate(my_type::foo, stat=stat_var)
    allocate(double precision::foo)
    allocate(my_type::bar(1), foo, parent%child%grandchild(1, 2), errmsg=msg)
    allocate(parent(n)%child(x, y))
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (allocate_statement
      allocation: (sized_allocation
        (identifier)
        (size
          (number_literal)
          (number_literal))))
    (allocate_statement
      type: (intrinsic_type)
      allocation: (identifier))
    (allocate_statement
      type: (identifier)
      allocation: (identifier)
      (keyword_argument
        name: (identifier)
        value: (identifier)))
    (allocate_statement
      type: (intrinsic_type)
      allocation: (identifier))
    (allocate_statement
      type: (identifier)
      allocation: (sized_allocation
        (identifier)
        (size
          (number_literal)))
      allocation: (identifier)
      allocation: (sized_allocation
        (derived_type_member_expression
          (derived_type_member_expression
            (identifier)
            (type_member))
          (type_member))
        (size
          (number_literal)
          (number_literal)))
      (keyword_argument
        name: (identifier)
        value: (identifier)))
    (allocate_statement
      allocation: (sized_allocation
        (derived_type_member_expression
          (call_expression
            (identifier)
            (argument_list
              (identifier)))
          (type_member))
        (size
          (identifier)
          (identifier))))
    (end_program_statement
      (name))))

================================================================================
Arithmetic If Statement (Deleted)
================================================================================

  if (d) 10, 20, 30
end

--------------------------------------------------------------------------------

(translation_unit
  (program
    (arithmetic_if_statement
      (parenthesized_expression
        (identifier))
      (statement_label_reference)
      (statement_label_reference)
      (statement_label_reference))
    (end_program_statement)))

================================================================================
Statement Functions (Obsolescent)
================================================================================

      SUBROUTINE CEBCHVXX( THRESH, PATH )      
      COMPLEX            ZDUM
!     .. Statement Functions ..
      REAL               CABS1
!     ..
!     .. Statement Function Definitions ..
      CABS1( ZDUM ) = ABS( REAL( ZDUM ) ) + ABS( AIMAG( ZDUM ) )

!     .. Parameters ..
      INTEGER            NWISE_I, CWISE_I
      PARAMETER          (NWISE_I = 1, CWISE_I = 1)

      FACT = 'E'
      END SUBROUTINE CEBCHVXX

--------------------------------------------------------------------------------

(translation_unit
  (subroutine
    (subroutine_statement
      (name)
      (parameters
        (identifier)
        (identifier)))
    (variable_declaration
      (intrinsic_type)
      (identifier))
    (comment)
    (variable_declaration
      (intrinsic_type)
      (identifier))
    (comment)
    (comment)
    (assignment_statement
      (call_expression
        (identifier)
        (argument_list
          (identifier)))
      (math_expression
        (call_expression
          (identifier)
          (argument_list
            (call_expression
              (identifier)
              (argument_list
                (identifier)))))
        (call_expression
          (identifier)
          (argument_list
            (call_expression
              (identifier)
              (argument_list
                (identifier)))))))
    (comment)
    (variable_declaration
      (intrinsic_type)
      (identifier)
      (identifier))
    (parameter_statement
      (parameter_assignment
        (identifier)
        (number_literal))
      (parameter_assignment
        (identifier)
        (number_literal)))
    (assignment_statement
      (identifier)
      (string_literal))
    (end_subroutine_statement
      (name))))

================================================================================
Entry statement (Obsolescent)
================================================================================

       SUBROUTINE SUB(A, B, C)
       INTEGER A, B
       CHARACTER C*4

       RETURN

       ENTRY SUB2(A, B, C)
       RETURN

       ENTRY SUB3
       RETURN
       END

--------------------------------------------------------------------------------

(translation_unit
  (subroutine
    (subroutine_statement
      (name)
      (parameters
        (identifier)
        (identifier)
        (identifier)))
    (variable_declaration
      (intrinsic_type)
      (identifier)
      (identifier))
    (variable_declaration
      (intrinsic_type)
      (sized_declarator
        (identifier)
        (character_length)))
    (keyword_statement)
    (entry_statement
      (name)
      (parameters
        (identifier)
        (identifier)
        (identifier)))
    (keyword_statement)
    (entry_statement
      (name))
    (keyword_statement)
    (end_subroutine_statement)))

================================================================================
Coarray declarations
================================================================================

program test
 integer :: a[*]
 integer :: i[-2:2,2,1:*]
 integer, allocatable, codimension[:] :: co_int_scal_k1
 integer :: a(num_local_elems)[*]=a_initial, b(num_local_elems)[*]=b_initial
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (variable_declaration
      (intrinsic_type)
      (coarray_declarator
        (identifier)
        (coarray_size)))
    (variable_declaration
      (intrinsic_type)
      (coarray_declarator
        (identifier)
        (coarray_size
          (extent_specifier
            (unary_expression
              (number_literal))
            (number_literal))
          (number_literal)
          (extent_specifier
            (number_literal)))))
    (variable_declaration
      (intrinsic_type)
      (type_qualifier)
      (type_qualifier
        (coarray_size
          (extent_specifier)))
      (identifier))
    (variable_declaration
      (intrinsic_type)
      (init_declarator
        (coarray_declarator
          (sized_declarator
            (identifier)
            (size
              (identifier)))
          (coarray_size))
        (identifier))
      (init_declarator
        (coarray_declarator
          (sized_declarator
            (identifier)
            (size
              (identifier)))
          (coarray_size))
        (identifier)))
    (end_program_statement
      (name))))

================================================================================
Coarray indexing
================================================================================

program test
  print*, a[5]
  ok[1] = .false.
  a(:)[right] = a(:)[right]+me
  if(me == 1) x[2, team = initial] = me
  allocate(a(5)[*])
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (print_statement
      (format_identifier)
      (output_item_list
        (coarray_expression
          (identifier)
          (coarray_index
            (number_literal)))))
    (assignment_statement
      (coarray_expression
        (identifier)
        (coarray_index
          (number_literal)))
      (boolean_literal))
    (assignment_statement
      (coarray_expression
        (call_expression
          (identifier)
          (argument_list
            (extent_specifier)))
        (coarray_index
          (identifier)))
      (math_expression
        (coarray_expression
          (call_expression
            (identifier)
            (argument_list
              (extent_specifier)))
          (coarray_index
            (identifier)))
        (identifier)))
    (if_statement
      (parenthesized_expression
        (relational_expression
          (identifier)
          (number_literal)))
      (assignment_statement
        (coarray_expression
          (identifier)
          (coarray_index
            (number_literal)
            (keyword_argument
              (identifier)
              (identifier))))
        (identifier)))
    (allocate_statement
      (coarray_allocation
        (sized_allocation
          (identifier)
          (size
            (number_literal)))
        (coarray_size)))
    (end_program_statement
      (name))))

================================================================================
Coarray statements
================================================================================

program test
  sync images(1)
  sync images([1, 3])
  sync all
  form team(1, team(PARENT_TEAM))
  sync team(team(PARENT_TEAM))
  lock (lck[1])
  unlock (lck[1])
  notify wait(nx, until_count=1)
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (coarray_statement
      (argument_list
        (number_literal)))
    (coarray_statement
      (argument_list
        (array_literal
          (number_literal)
          (number_literal))))
    (coarray_statement)
    (coarray_statement
      (argument_list
        (number_literal)
        (call_expression
          (identifier)
          (argument_list
            (identifier)))))
    (coarray_statement
      (argument_list
        (call_expression
          (identifier)
          (argument_list
            (identifier)))))
    (coarray_statement
      (argument_list
        (coarray_expression
          (identifier)
          (coarray_index
            (number_literal)))))
    (coarray_statement
      (argument_list
        (coarray_expression
          (identifier)
          (coarray_index
            (number_literal)))))
    (coarray_statement
      (argument_list
        (identifier)
        (keyword_argument
          (identifier)
          (number_literal))))
    (end_program_statement
      (name))))

================================================================================
Coarray Change Team
================================================================================

program test
  form team(parent_team_number, parent)
  change team(parent)
    form team(child_team_number, child)
    child_team: change team(child)
      print*, this_image(), team_number(), team_number(child), team_number(parent)
    end team child_team
  end team
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (coarray_statement
      (argument_list
        (identifier)
        (identifier)))
    (coarray_team_statement
      (argument_list
        (identifier))
      (coarray_statement
        (argument_list
          (identifier)
          (identifier)))
      (coarray_team_statement
        (block_label_start_expression)
        (argument_list
          (identifier))
        (print_statement
          (format_identifier)
          (output_item_list
            (call_expression
              (identifier)
              (argument_list))
            (call_expression
              (identifier)
              (argument_list))
            (call_expression
              (identifier)
              (argument_list
                (identifier)))
            (call_expression
              (identifier)
              (argument_list
                (identifier)))))
        (end_coarray_team_statement
          (block_label)))
      (end_coarray_team_statement))
    (end_program_statement
      (name))))

================================================================================
Coarray Critical
================================================================================

program test
  critical
    ok[1] = .false.
  end critical
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (coarray_critical_statement
      (assignment_statement
        (coarray_expression
          (identifier)
          (coarray_index
            (number_literal)))
        (boolean_literal))
      (end_coarray_critical_statement))
    (end_program_statement
      (name))))

================================================================================
Extra semicolon
================================================================================

program test;
        ;
  implicit none;
  integer :: foo; ; foo = 1
end program test;

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (implicit_statement
      (none))
    (variable_declaration
      (intrinsic_type)
      (identifier))
    (assignment_statement
      (identifier)
      (number_literal))
    (end_program_statement
      (name))))

================================================================================
Dollar in identifiers (extension)
================================================================================

program test
  integer, parameter :: foo$ = 1
end program test

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (variable_declaration
      (intrinsic_type)
      (type_qualifier)
      (init_declarator
        (identifier)
        (number_literal)))
    (end_program_statement
      (name))))

================================================================================
Typeof, classof declarations
================================================================================

subroutine test(a, b, c, d)
  integer, intent(in) :: a
  typeof(a), intent(in) :: b(size(a))
  type(foo) :: c
  classof(c%d) :: d
end subroutine test

--------------------------------------------------------------------------------

(translation_unit
  (subroutine
    (subroutine_statement
      name: (name)
      parameters: (parameters
        (identifier)
        (identifier)
        (identifier)
        (identifier)))
    (variable_declaration
      type: (intrinsic_type)
      attribute: (type_qualifier)
      declarator: (identifier))
    (variable_declaration
      type: (declared_type
        name: (identifier))
      attribute: (type_qualifier)
      declarator: (sized_declarator
        (identifier)
        (size
          (call_expression
            (identifier)
            (argument_list
              (identifier))))))
    (variable_declaration
      type: (derived_type
        name: (type_name))
      declarator: (identifier))
    (variable_declaration
      type: (declared_type
        name: (derived_type_member_expression
          (identifier)
          (type_member)))
      declarator: (identifier))
    (end_subroutine_statement
      (name))))

================================================================================
Assign Statement (Deleted)
================================================================================

  assign 4 to x
end

--------------------------------------------------------------------------------

(translation_unit
  (program
    (assign_statement
      (number_literal)
      (identifier))
    (end_program_statement)))

================================================================================
Alternate Return Statement (Obsolescent)
================================================================================

  return 1
end

--------------------------------------------------------------------------------

(translation_unit
  (program
    (keyword_statement
      (number_literal))
    (end_program_statement)))

================================================================================
Assigned Goto (Deleted)
================================================================================

program test
  goto NEXT, (10, 20, 30)
end program

--------------------------------------------------------------------------------

(translation_unit
  (program
    (program_statement
      (name))
    (keyword_statement
      (identifier)
      (statement_label_reference)
      (statement_label_reference)
      (statement_label_reference))
    (end_program_statement)))

================================================================================
Cray pointer (extension)
================================================================================

SUBROUTINE  sub ( n )
  COMMON pool(100000)
  INTEGER blk(128), word64
  REAL a(1000), b(n), c(100000-n-1000)
  POINTER ( pblk, blk ), (ia, a(10:100) ), ( ib, b ), &
          ( ic, c ), ( address, word64 )
END SUBROUTINE sub

subroutine pointer_name_clash
  integer, dimension(2) :: pointer
  pointer(1, 1) = 4
end subroutine pointer_name_clash

--------------------------------------------------------------------------------

(translation_unit
  (subroutine
    (subroutine_statement
      name: (name)
      parameters: (parameters
        (identifier)))
    (common_statement
      (sized_declarator
        (identifier)
        (size
          (number_literal))))
    (variable_declaration
      type: (intrinsic_type)
      declarator: (sized_declarator
        (identifier)
        (size
          (number_literal)))
      declarator: (identifier))
    (variable_declaration
      type: (intrinsic_type)
      declarator: (sized_declarator
        (identifier)
        (size
          (number_literal)))
      declarator: (sized_declarator
        (identifier)
        (size
          (identifier)))
      declarator: (sized_declarator
        (identifier)
        (size
          (math_expression
            left: (math_expression
              left: (number_literal)
              right: (identifier))
            right: (number_literal)))))
    (cray_pointer_declaration
      (cray_pointer_pair
        pointer: (identifier)
        target: (identifier))
      (cray_pointer_pair
        pointer: (identifier)
        target: (sized_declarator
          (identifier)
          (size
            (extent_specifier
              (number_literal)
              (number_literal)))))
      (cray_pointer_pair
        pointer: (identifier)
        target: (identifier))
      (cray_pointer_pair
        pointer: (identifier)
        target: (identifier))
      (cray_pointer_pair
        pointer: (identifier)
        target: (identifier)))
    (end_subroutine_statement
      (name)))
  (subroutine
    (subroutine_statement
      name: (name))
    (variable_declaration
      type: (intrinsic_type)
      attribute: (type_qualifier
        (argument_list
          (number_literal)))
      declarator: (identifier))
    (assignment_statement
      left: (call_expression
        (identifier)
        (argument_list
          (number_literal)
          (number_literal)))
      right: (number_literal))
    (end_subroutine_statement
      (name))))
